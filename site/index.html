<!DOCTYPE HTML>
<html>
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html">
    <title>Moqui Framework</title>
    <link rel="stylesheet" href="basic.css" type="text/css">
    <meta name="keywords" content="moqui,framework,java,jee,j2ee,enterprise,groovy,freemarker,ofbiz,service,entity,database,transaction,screen,xml">
</head>
<body>

<!-- canvas start -->
<div id="canvas">

<!-- header start -->
<div id="header">
    <div class="left">
        <h1><a href="http://www.moqui.org/">Moqui Framework</a></h1>
    </div>
    <div class="right">
        <a href="http://sourceforge.net/"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=302949&amp;type=16" alt="SourceForge.net"></a>
    </div>
    <div class="endcolumns"><span>&nbsp;</span></div>
</div>
<!-- header end -->

<!-- content start -->
<div id="content">
    <div id="link-column">
        <!-- structure:
        <h2>Header</h2>
        <h3>Sub-header</h3>
        <a href="http://link.com/">link</a>
        -->
        <!-- once a download is ready...
        <h2>Download</h2>
        <a href="foo">bar</a>
        -->
        <h2>Resources</h2>
        <a href="http://sourceforge.net/projects/moqui/files">Download</a>
        <a href="http://sourceforge.net/project/project_donations.php?group_id=302949">Donate</a>
        <a href="https://sourceforge.net/scm/?type=svn&group_id=302949">Code Repository (SVN)</a>
        <a href="https://sourceforge.net/news/?group_id=302949">News</a>
        <a href="https://sourceforge.net/projects/moqui/forums/forum/1114444">Peer Support</a>
        <a href="https://sourceforge.net/projects/moqui/forums/forum/1086127">Open Discussion</a>
        <a href="https://sourceforge.net/tracker/?group_id=302949&atid=1277176">Bug Tracker</a>
        <a href="https://sourceforge.net/tracker/?group_id=302949&atid=1277179">Feature Requests</a>
        <a href="http://sourceforge.net/projects/moqui">SourceForge Site</a>

        <h2>Built On</h2>
        <a href="http://www.groovy.org/" target="_blank">Groovy</a>
        <a href="http://www.freemarker.org/" target="_blank">FreeMarker</a>
        <a href="http://www.ehcache.org/" target="_blank">ehcache</a>
        <a href="http://www.quartz-scheduler.org/" target="_blank">Quartz Scheduler</a>
        <a href="http://www.atomikos.com/" target="_blank">Atomikos TransactionsEssentials</a>
        <a href="http://code.google.com/p/owasp-esapi-java/" target="_blank">OWASP ESAPI</a>
        <a href="http://wiki.eclipse.org/Mylyn/Incubator/WikiText" target="_blank">Mylyn WikiText</a>
        <a href="http://winstone.sourceforge.net/" target="_blank">Winstone Servlet Container</a>
        <a href="http://tomcat.apache.org/" target="_blank">Apache Tomcat</a>
        <a href="http://jackrabbit.apache.org/" target="_blank">Apache JackRabbit</a>
        <a href="http://commons.apache.org/" target="_blank">Apache Commons</a>
        <a href="http://www.slf4j.org/" target="_blank">SLF4J</a>

        <h2>Services</h2>
        <a href="http://www.dejc.com/" target="_blank">David E. Jones Consulting</a>
    </div>

    <div id="detail-column">
        <div id="status">
            <h2><a href="javascript:toggleView('status_area');" id="status_area_link"><span class="expanded"></span>-</a>
                Status: 2nd Preview Release Available, Implementation In Progress</h2>
            <div id="status_area">
                <p>The Moqui Framework is currently being implemented. The design for version 1.0 was completed in
                    late 2010. Most tools and features are already implemented and available in the
                    latest preview release (various preview releases will be done during early 2011).
                    The feature-complete 1.0 beta release is planned for Summer 2011 and the production stable release
                    for Fall 2011.</p>
                <p>While not feature-complete for the planned 1.0 feature set, the 1.0-preview2 release is ready for
                    early adopters for proof-of-concept or longer-term projects. Feedback and help with testing is
                    critical at this stage in the project and now is the time for feedback that can have an effect
                    on the scope and direction of the framework.</p>
                <p>Try the latest release by downloading the
                    <a href="http://sourceforge.net/projects/moqui/files">binary or source distribution</a> and following
                    the instructions in the <b>RunDeploy.txt</b> file available in the download or
                    <a href="http://moqui.svn.sourceforge.net/viewvc/moqui/trunk/moqui/RunDeploy.txt">online through SVN here</a>.</p>
                <p>If you would like to help move things along faster, please
                    <a href="http://sourceforge.net/project/project_donations.php?group_id=302949">Donate</a> or
                    contact <a href="http://www.dejc.com/">David E. Jones</a> to sponsor specific features.</p>
            </div>
        </div>
        <div id="intro">
            <h2><a href="javascript:toggleView('intro_area');" id="intro_area_link"><span class="expanded"></span>-</a>
                Introduction: What is Moqui?</h2>
            <div id="intro_area">
                <p>The Moqui Framework is an integrated tool set with everything needed to start
                building web-based and distributed enterprise applications right away. Rather
                than starting with a set of tools and figuring out how to use them together
                and filling in gaps that are not handled by default, Moqui is ready to go.</p>

                <p>The framework features a well-defined Java API that makes it easy to get at
                the features listed below, especially in Groovy code. What's even better is
                that the Moqui tools are designed to be used in a declarative way so most of
                what you need to do will be possible with XML configuration and little or no
                code, unless you want it of course.</p>
            </div>
        </div>
        <div id="model">
            <h2><a href="javascript:toggleView('model_area');" id="model_area_link"><span class="expanded"></span>-</a>
                Model: License? Resources?</h2>
            <div id="model_area">
                <h3>License</h3>
                <p>Moqui is (real) free software.</p>
                <p>In open source terminology it is both free as in beer (gratis) and free as
                    in liberty (libre). The free as in liberty part for Moqui means real liberty. It does not mean the
                    pages of cumbersome restrictions and threats of legal action that has passed for liberty in the
                    open source movement. It means no restrictions and no obligations and no protection of monopoly
                    enforced by collaboration with any government. It means that the ubiquitous disclaimer of
                    liability is accompanied by a similar disclaimer of copyrights.</p>
                <p>Moqui is in the public domain.</p>

                <h3>Resources and Management</h3>
                <p>To maintain a high level of quality and provide for long-term sustainable maintenance Moqui
                    is operated using a professionally moderated code base model. This model is based on free-market
                    principles and takes in account the motivations and needs of all parties involved:</p>
                <ul>
                    <li>user: any user of the software (developer, end-user, etc)</li>
                    <li>sponsor: anyone who backs new features and changes to the software</li>
                    <li>contributor: developer who contributes code and then hires (and collaborates with) a moderator
                        to make it part of the project</li>
                    <li>moderator: developer with commit access to the official code repository and who personally works
                        on the design and development and maintenance of the software (intentionally very small group)</li>
                </ul>
                <p>No changes go into the official code repository without detailed personal review by one of the
                    moderators.
                    It is common for users of software to want certain things to be different, or
                    new things to be added. Under this model the normal way to get this done is to pay a moderator to
                    either implement the desired changes, or review a patch from the contributor, make revisions as
                    needed and possibly commit the changes.</p>
                <p>Under this model:<p>
                <ul>
                    <li>users get a piece of software that is well thought out and thoroughly reviewed</li>
                    <li>users save time wasted by meaningless changes causing them problems</li>
                    <li>users don't have to worry about bad changes being committed without thorough review</li>
                    <li>users can count on a framework that will be around for a long time</li>
                    <li>contributors don't wait endlessly for feedback or worry about contributions being ignored</li>
                    <li>contributors can count on detailed feedback and, as needed, discussion and collaboration
                        to get the best possible change committed, or a good explanation of why it won't be</li>
                    <li>sponsors enjoy fast response times to requests for new features or other changes</li>
                    <li>the software stays aligned with the design goals</li>
                    <li>the software does not suffer from decay over many years of life as random people scratch random
                        itches or commit for convenience based on obtuse requirements from clients</li>
                </ul>
            </div>
        </div>
        <div id="choose">
            <h2><a href="javascript:toggleView('choose_area');" id="choose_area_link"><span class="expanded"></span>-</a>
                Design: Why choose Moqui?</h2>
            <div id="choose_area">
                <p>When selecting an enterprise application framework there are many criteria
                to consider. These criteria drove the design of Moqui:</p>

                <h3>Strong Best Practices</h3>
                <p>Your mother probably encouraged you to maintain a policy of: "A place for everything, and everything
                    in its place." For enterprise frameworks best practices involve identifying common development needs
                    and having a tool planned for each (or sometimes a primary and secondary best practice). Some needs
                    to consider include:</p>
                <ul>
                    <li>process incoming data</li>
                    <li>structure multi-area pages/screens</li>
                    <li>gather and prepare data for output</li>
                    <li>format/layout output</li>
                    <li>business (service) logic (including persistence related operations)</li>
                    <li>service orchestration, process triggering, etc</li>
                    <li>define business data structures</li>
                    <li>route web requests (process incoming data, render responses)</li>
                    <li>route logic calls (support remote and local implementations, sync/async/scheduled execution,
                        tx mgmt, security, etc)</li>
                </ul>
                <p>The main point here is consistency. There is an efficiency aspect to this, but more on that later.
                    This becomes more important as teams and projects get larger, and where teams are distributed or too
                    large to interact closely and have common review of the artifacts produced. Without these guidelines
                    developers spend a lot of time researching possible tools, learning about tools others have used,
                    and dealing with differences in tools when working on requirements that across a large application.</p>
                <p>In some cases the choice for a "primary" best practice tool handle most cases really well, but
                    doesn't handle certain things very well (or at all). In those cases a "secondary" best practice tool
                    should also be specified along with reasons when it should be used.</p>

                <h3>Minimal Tool Set Redundancy</h3>
                <p>A small set of tools provides various benefits both during initial development, and to an even
                    greater extent, in ongoing maintenance and improvements:</p>
                <ul>
                    <li>less technology switching as people work in different areas of the applications</li>
                    <li>less segmentation of development groups in your organization</li>
                    <li>easier to read, review, and maintain code</li>
                    <li>more consistency among the artifacts</li>
                    <li>easier choice of tools and areas to build things in as new designs are ready for implementation
                        or existing designs are changed</li>
                    <li>easier for new people to learn the technologies (with fewer technologies to learn)</li>
                </ul>
                <p>Individual developers may not be familiar with the set of tools chosen, and they may prefer the tools
                they are already familiar with (sometimes with strong bias). Some set of tools has to be chosen or you
                end up with the opposite of the benefits above. In the long run, and often short-term as well, a smaller
                tool set is better for both individuals and organizations.</p>

                <h3>Efficient Tools</h3>
                <p>This is #3 for a reason. If the overall tool set and practices are not adequate the benefits from
                    efficient tools will be lost in the noise and overrun by the problems caused by other things.
                    Efficient development tools result in development artifacts that are (in order of importance):</p>
                <ul>
                    <li>simple</li>
                    <li>reusable by design</li>
                    <li>easy to read as well as write</li>
                    <li>minimally error prone</li>
                    <li>small</li>
                </ul>
                <p>Some tools are great for small and simple applications, but the size and complexity of artifacts
                    scale poorly, resulting in applications that are unnecessarily large and complex.</p>

                <h3>Existing Artifacts</h3>
                <p>What existing artifacts (code, etc) do you have that you plan to continue using? Which tools were
                    are those artifacts based on? The existing artifacts may include custom developed or packaged
                    software, and may be currently in use or planned to be introduced as part of the project.</p>
                <p>This is a lower priority because rewriting existing artifacts in a consistent way might not be better
                    for initial development, but is definitely better for ongoing customization, extension, and
                    maintenance. While this may seem expensive and difficult, there are various factors that make it
                    easier than writing the original code:</p>
                <ul>
                    <li>existing artifacts represent a detailed specification that includes business and technical
                        details, and nuances that would otherwise need to be defined or made up along the way</li>
                    <li>more junior developers can work on re-writing the code than were involved with the original</li>
                    <li>less risk involved in rewriting than was originally there for the initial design and build</li>
                </ul>

                <h3>Summary</h3>
                <p>As projects and teams get larger and go on longer a comprehensive and well organized set of tools
                    can make the difference between costs growing exponentially and smooth sailing with minimal
                    surprises as new requirements arise or changes are needed.</p>
                <p>The Moqui Framework is based on a decade of experience designing the tools of the Apache OFBiz
                    Framework using real-world business application requirements, and actually using those tools to
                    build a system with a set of artifacts that have been reused and built on to create thousands of
                    custom systems and dozens of open source and commercial derivative works. All of this was driven
                    by people who do customization for a living, so tools that facilitate customization were a high
                    priority.</p>
                <p>So why Moqui? As OFBiz and the community around it grew in size it became more difficult to make
                    dramatic changes to the framework and tools used in the project. Ideas kept coming about ways to
                    improve things, organize artifacts better, use convention over configuration, get rid of redundant
                    and unused tools, and generally make things more consistent. The Moqui Framework is the result of
                    all of these experiences and ideas, combined into innovative and fresh ways to build the best
                    applications in the shortest time and with the easiest to maintain artifacts.</p>
            </div>
        </div>
        <div id="features">
            <h2><a href="javascript:toggleView('features_area');" id="features_area_link"><span class="expanded"></span>-</a>
                Features: What does Moqui Do?</h2>
            <div id="features_area">
                <p>The Moqui Framework includes:</p>
                <ul>
                    <li>Database (entity) facade for data tier
                        <ul>
                            <li>Define your entities and go, no code to write and no redundancy</li>
                            <li>Java API or XML tags for a wide variety of queries and common operations</li>
                            <li>Event-Condition-Action rules to do things based on data changes</li>
                            <li>Data import and export tools, including for seed and other setup data</li>
                            <li>Support for Derby, HSQL, PostgreSQL, MySQL, and Oracle OOTB, and easy to
                              add support for other databases, usually just through configuration</li>
                        </ul>
                    </li>
                    <li>Service-based logic tier
                        <ul>
                            <li>Call services synchronously, async, or scheduled</li>
                            <li>Scheduled and async calls backed by Quartz Scheduler</li>
                            <li>Services can be local or remote and implemented in a variety of languages</li>
                            <li>Flexible XML service definitions</li>
                            <li>Validation of data type, required or not, regexp, and other constraints;
                              validation runs on server and in client with JavaScript library</li>
                            <li>Event-Condition-Action rules to orchestrate high level processes,
                              externally change or augment behavior of existing services, and much more</li>
                        </ul>
                    </li>
                    <li>Screen-based user interface tier
                        <ul>
                            <li>Declarative multi-platform screens, text templates, or any combination</li>
                            <li>Generate HTML, XML, PDF (XSL-FO), or drive GWT or Swing screens</li>
                            <li>Screen files and included sets of subscreens in directories with the same
                              structure as the application</li>
                            <li>Nested subscreens for multiple levels of tabs or other types of menus</li>
                            <li>Data preparation logic declared with screens to make each screen modular</li>
                            <li>Outgoing transitions point to input processing logic and conditional
                              forwarding to other screens or external URLs</li>
                            <li>Forms (single, list), trees, panels, and various other common widgets</li>
                        </ul>
                    </li>
                    <li>Manage incoming and outgoing email</li>
                    <li>Uses JTA transaction management and JDBC connection pool from JNDI, or
                        internally managed with Atomikos TransactionsEssentials</li>
                    <li>Uses Groovy for scripting and Freemarker for templates</li>
                    <li>JCR 2.0 (JSR-283) based content and artifact management with Apache JackRabbit</li>
                    <li>Implicit internationalization and easy database-driven localization</li>
                    <li>Comprehensive security with declarative authorization
                        <ul>
                            <li>Settings in the database, separate from implementation artifacts</li>
                            <li>Define run-time inheritable permissions for any artifact in the system</li>
                            <li>Both record level and implementation artifact level security</li>
                        </ul>
                    </li>
                    <li>Protection from XSS and XSRF threats (uses ESAPI and Antisamy)</li>
                    <li>Flexible resource access from files, JCR repository, and many others</li>
                    <li>Cache management for framework and application resources backed by ehcache</li>
                    <li>Multi-tenant architecture (single application, one database per tenant)</li>
                    <li>Logging using SLF4J</li>
                    <li>Common business data structures and seed data
                        <ul>
                            <li>Enumerations and statuses with transitions</li>
                            <li>Units of measure with conversion, including currency</li>
                            <li>Geographic boundaries (legal and arbitrary) and points</li>
                            <li>Time periods</li>
                        </ul>
                    </li>
                    <li>Service/logic and data level integration options</li>
                    <li>Data migration and mapping tools (especially for to/from XML, to/from db)</li>
                    <li>Flexible deployment and init/destroy model (WAR, static, OSGi, Spring)
                        <ul>
                            <li>Easy deployment with the framework in a WAR file and a separate runtime
                              directory with your configuration, application components, log files,
                              database and content repository files, and so on</li>
                            <li>Can also deploy without a servlet container using Static initialization or
                              custom init for OSGi, Spring, etc</li>
                        </ul>
                    </li>
                </ul>
            </div>
        </div>
        <div id="ofbcompare">
            <h2><a href="javascript:toggleView('ofbcompare_area');" id="ofbcompare_area_link"><span class="expanded"></span>-</a>
                OFBiz: How does it compare to Moqui?</h2>
            <div id="ofbcompare_area">
                <h3>ControlServlet, widgets (screen, form, menu, tree):</h3>

                <p>These tools are now all combined into the Moqui XML Screens.</p>

                <p>There are no explicit menus and instead there are subscreens and a menu is
                automatically generated from the set of subscreens in a screen.</p>

                <p>Instead of using the decoration pattern the XML Screens use subscreens to
                compose an hierarchy of screens. The subscreens for a screen can be
                configured in three different ways for different purposes including: a
                directory structure plus defaults for a normal screen/subscreens hierarchy,
                an XML element to include screens from other applications or that aren't in
                any application, and a database table that allows add-on component to add
                a subscreen to an existing screen somewhere else.</p>

                <p>It is not an option to have multiple XML Screens in a single file. Each file
                represents a single screen to make it easier to see what an application looks
                like just by browsing the directory structure, kind of like it is for webapps
                with normal templates and such.</p>

                <p>Forms and trees are kept in separate files and are simply in-lined
                in a screen. It is possible to refer to forms externally using the
                screen's file location and the name of the form.</p>

                <p>The widgets don't have any style attributes that will be used for HTML
                class attributes. There are id attributes in various places, but the intent
                is to use automatic id and class elements based on names and types of
                elements in the XML Screens and then keep all of the styling in an external
                CSS file.</p>

                <p>There aren't any AJAX- and HTML-specific elements and attributes. This
                goes back to the original intent of the OFBiz widgets and that is to be purely
                declarative and platform independent. Many XML Screens elements will be
                implemented using AJAX and DHTML, and options to control those or add to them
                will be available.</p>

                <h3>MiniLang simple-methods, screen/form/etc actions</h3>

                <p>All operations from these various places are combined in one XSD file
                and are referred to as XML Actions. These are included in various places
                using the "actions" and "condition" elements. With this approach there is no
                inconsistency for similarly named and designed operations or conditions.</p>

                <p>Moqui XML Actions don't have operations that are not frequently used and some
                operations are like a combination of various simple-method operations. There
                are operations for a few additional things as well, like producing and
                consuming XML.</p>

                <p>Some operations that are inconsistent in different places in OFBiz, like
                calling a service, have all similar features combined into one far more useful
                operation.</p>

                <p>There is no performFind service needed in Moqui as the entity-find operation
                has an element that takes its place, and can be combined with various other
                elements of a find by condition for a great deal of flexibility that is
                easily usable.</p>

                <p>The actions are available in many more places including ECA rules, screen
                transitions (like the OFBiz controller request events), and others.</p>

                <h3>Service definitions and implementations</h3>

                <p>The OFBiz Service Engine is most like the Service Facade in Moqui. There are
                many other facades, and for more info see the API Structure section below.</p>

                <p>Service names are split into verb and noun parts, which together make up the
                service name (ie like: ${verb}${noun}). Services are called with the combined
                name and can separate the verb and noun parts of it using a hash mark ('#').
                Services are also organized by path just like Java classes to facilitate lazy
                loading and to better organize code. The full name of a service will follow a
                pattern like: "${path}.${verb}${noun}".</p>

                <p>Service parameters in Moqui are like the service attributes in OFBiz.</p>

                <p>Service parameters are split into two groups: "in-parameters" and
                "out-parameters" so that parameters with the same name can have different
                settings going into or coming out of the service.</p>

                <p>Parameters in Moqui have hierarchical sub-types for map and collection types.</p>

                <p>Parameters have a fairly complete set of validation tags. Those
                validation tags will be used for server-side validation when the service is
                called, AND when the service is a target on a screen transition it will be
                used to generate client-side validation in JavaScript. This validation
                is defined once but run in both places.</p>

                <p>As mentioned above XML Actions are available in many places, and one of those
                places is inside a service definition. With this a service implementation can
                be inline inside the service definition or external depending on preference.</p>

                <h3>Entity Engine</h3>

                <p>The OFBiz Entity Engine is most like the Entity Facade in Moqui. There are
                many other facades, and for more info see the API Structure section below.</p>

                <p>Entity definitions are more streamlined and don't have the less useful
                attributes and elements. Primary key fields are designated with an attribute
                on the field element instead of using a separate element. The data type
                dictionary in Moqui is more simple and better organized than in OFBiz and
                the data types available are declared in the XSD for auto-completion help.</p>

                <p>The API for dealing with entity values and for queries and such is much more
                simple, streamlined, and in a few small cases has additional functionality.
                The methods have far more consistent names than in OFBiz, using
                create/update/delete everywhere instead of things like store or remove.</p>

                <p>Moqui does not have a concept of multiple delegators so the Entity Proxy
                configuration file is much more simple. The datasource elements are also far
                more simple because all of the database-specific settings are now in the
                database configuration file along with the data type dictionary (combined in
                one file instead of a separate file for each database).</p>

                <h3>API structure</h3>

                <p>The Moqui API is clearly separate into interfaces and implementations of
                those interfaces. Applications only need to worry about the interfaces part
                of the Java code and not the underlying implementation.</p>

                <p>All tools in the Moqui framework are available through the ExecutionContext
                object, which is created and attached to a thread for each web request,
                remotely called service, etc. It keeps the current context for whatever is
                running and has a series of facades for each tool in the framework, including
                for sevices, entities, screens, localization, logging, caching, user info
                and preferences, and so on. Some of the implementations of these interfaces
                will be reusable from one thread to another, and others will be created for
                each thread.</p>

                <p>The API is designed to take advantage of some of the syntax short cuts in
                Groovy such as using the dot syntax to start with the Moqui static object and
                get down to whatever part of the API you need.</p>

                <h3>Configuration and code layout</h3>

                <p>In Moqui the framework is one big happy set of tools that work together.
                There is no attempt to separate the tools or make them useful on their own.
                That was goal at first with OFBiz, but never really worked out very well and
                splitting the framework into components caused more difficulty than it helped
                things. So, in Moqui it's all one big framework, and one that can be easily
                compiled and deployed and so on. The basic idea is that the framework jar
                files (api and implementation) on the classpath plus the locaiton of the
                runtime directory are all you need to get started. Components can be loaded
                through an API or configuration.</p>

                <p>Configuration files are meant to come from a runtime directory and are not
                spread around the code. There is a default-conf directory in the framework
                so that if a configuration file is left out the framework will have a default
                to fallback on that will work in most cases.</p>

                <p>While Moqui supports multiple webapps, the normal deployment mode is be as
                a single big webapp with screen trees from add on components mounted on a
                certain path within the big webapp.</p>

                <h3>Content management</h3>

                <p>Instead of a set of entities and services for content management that are
                part of the project Moqui uses the JCR 2.0 interfaces (and by default the
                Apache Jackrabbit implementation) for content management. Anywhere there is
                a "location" in the API or XML files it can have a prefix of "content://" to
                access something from the JCR. This means that code and templates and such
                can go there as well.</p>

                <h3>Security: authorization</h3>

                <p>Moqui uses a set of entities to define user groups, artifact groups, and
                permissions for a group of users on a group of artifacts. These are external
                settings and support record level permissions too. With this approach there
                is no need make the artifacts responsible for permission checking, and no
                code changes are required to change permissions when customizing or
                maintaining or supporting an application.</p>

                <p>There is a tarpit, like the idea in OFBiz, that uses the same model as the
                permissions for reduced redundancy and more features.</p>

                <h3>I18n and L10n</h3>

                <p>Internationalization is implicit everywhere in Moqui using natural text in
                the default language for a key instead of an artificial identifier. This
                reduces redundancy and effort. The localized labels are in a database table
                instead of an XML file to perform better (only lookup and cache labels that
                are used) and to support per-tenant localizations in a multi-tenant
                environment.</p>
            </div>
        </div>
        <!-- for future reference...
        <div id="users">
            <h2>Who is Using Moqui?</h2>
            <p>foo</p>
            <p>links here: <a href="bar" target="_blank">baz</a></p>
        </div>
        <div id="announcements"/>
        <div id="inthenews"/>
        -->
    </div>
    <div class="endcolumns"><span>&nbsp;</span></div>
</div>
<!-- content end -->

</div>
<!-- canvas end -->

<script language="javascript" type="text/javascript">
// if JavaScript is supported close the various elements to start
toggleView('intro_area');
toggleView('model_area');
toggleView('choose_area');
toggleView('features_area');
toggleView('ofbcompare_area');

function toggleView(item) {
    obj = document.getElementById(item);
    obj_link = document.getElementById(item + "_link");
    if (obj.style.display == "none") {
        obj.style.display = "block";
        obj_link.innerHTML = "<span class='expanded'></span>-";
    } else {
        obj.style.display="none";
        obj_link.innerHTML = "<span class='collapsed'></span>+";
    }
}
</script>

</body>
</html>
